/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: skFilter.c
 *
 * MATLAB Coder version            : 5.5
 * C/C++ source code generated on  : 19-Aug-2024 21:04:05
 */

/* Include Files */
#include "skFilter.h"
#include "skFilter_data.h"
#include "skFilter_initialize.h"
#include "skFilter_types.h"
#include <math.h>

/* Function Declarations */
static double rt_roundd_snf(double u);

/* Function Definitions */
/*
 * Arguments    : double u
 * Return Type  : double
 */
static double rt_roundd_snf(double u)
{
  double y;
  if (fabs(u) < 4.503599627370496E+15) {
    if (u >= 0.5) {
      y = floor(u + 0.5);
    } else if (u > -0.5) {
      y = u * 0.0;
    } else {
      y = ceil(u - 0.5);
    }
  } else {
    y = u;
  }
  return y;
}

/*
 * DOFILTER Filters input x and returns output y.
 *
 * Arguments    : const short x_data[]
 *                const int x_size[1]
 *                short y_data[]
 *                int y_size[2]
 * Return Type  : void
 */
void skFilter(const short x_data[], const int x_size[1], short y_data[],
              int y_size[2])
{
  dsp_BiquadFilter_0 *obj;
  double b_y_data[5000];
  double denAccum;
  int i;
  int ioIdx;
  int y_size_idx_0;
  if (!isInitialized_skFilter) {
    skFilter_initialize();
  }
  /*  MATLAB Code */
  /*  Generated by MATLAB(R) 9.13 and DSP System Toolbox 9.15. */
  /*  Generated on: 19-Aug-2024 19:50:09 */
  /*  To generate C/C++ code from this function use the codegen command. */
  /*  Type 'help codegen' for more information. */
  obj = &Hd.cSFunObject;
  /* System object Outputs function: dsp.BiquadFilter */
  y_size_idx_0 = x_size[0];
  ioIdx = 0;
  if (Hd.cSFunObject.W1_PreviousNumChannels == -1) {
    Hd.cSFunObject.W1_PreviousNumChannels = 1;
  }
  for (i = 0; i < x_size[0]; i++) {
    double tmpState;
    denAccum = obj->P3_RTP3COEFF[0] * (double)x_data[ioIdx];
    denAccum -= obj->P2_RTP2COEFF[0] * obj->W0_FILT_STATES[0];
    tmpState = denAccum - obj->P2_RTP2COEFF[1] * obj->W0_FILT_STATES[1];
    denAccum = obj->P1_RTP1COEFF[0] * tmpState;
    denAccum += obj->W0_FILT_STATES[0] * obj->P1_RTP1COEFF[1];
    denAccum += obj->W0_FILT_STATES[1] * obj->P1_RTP1COEFF[2];
    obj->W0_FILT_STATES[1] = obj->W0_FILT_STATES[0];
    obj->W0_FILT_STATES[0] = tmpState;
    denAccum *= obj->P3_RTP3COEFF[1];
    denAccum -= obj->P2_RTP2COEFF[2] * obj->W0_FILT_STATES[2];
    tmpState = denAccum - obj->P2_RTP2COEFF[3] * obj->W0_FILT_STATES[3];
    denAccum = obj->P1_RTP1COEFF[3] * tmpState;
    denAccum += obj->W0_FILT_STATES[2] * obj->P1_RTP1COEFF[4];
    b_y_data[ioIdx] = denAccum + obj->W0_FILT_STATES[3] * obj->P1_RTP1COEFF[5];
    obj->W0_FILT_STATES[3] = obj->W0_FILT_STATES[2];
    obj->W0_FILT_STATES[2] = tmpState;
    ioIdx++;
  }
  for (ioIdx = 0; ioIdx < y_size_idx_0; ioIdx++) {
    b_y_data[ioIdx] = rt_roundd_snf(b_y_data[ioIdx]);
  }
  y_size[0] = x_size[0];
  y_size[1] = 1;
  for (ioIdx = 0; ioIdx < y_size_idx_0; ioIdx++) {
    short b_i;
    denAccum = rt_roundd_snf(b_y_data[ioIdx]);
    if (denAccum < 32768.0) {
      if (denAccum >= -32768.0) {
        b_i = (short)denAccum;
      } else {
        b_i = MIN_int16_T;
      }
    } else if (denAccum >= 32768.0) {
      b_i = MAX_int16_T;
    } else {
      b_i = 0;
    }
    y_data[ioIdx] = b_i;
  }
}

/*
 * DOFILTER Filters input x and returns output y.
 *
 * Arguments    : void
 * Return Type  : void
 */
void skFilter_free(void)
{
  if (!Hd.matlabCodegenIsDeleted) {
    Hd.matlabCodegenIsDeleted = true;
  }
}

/*
 * DOFILTER Filters input x and returns output y.
 *
 * Arguments    : void
 * Return Type  : void
 */
void skFilter_init(void)
{
  Hd.matlabCodegenIsDeleted = true;
}

/*
 * File trailer for skFilter.c
 *
 * [EOF]
 */
